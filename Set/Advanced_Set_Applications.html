<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DSA Set - Advanced Applications</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
        }
        
        .container {
            background: white;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 15px 35px rgba(0,0,0,0.1);
        }
        
        h1 {
            color: #2d3748;
            text-align: center;
            margin-bottom: 30px;
            font-size: 2.5rem;
        }
        
        h2 {
            color: #4a5568;
            border-bottom: 3px solid #667eea;
            padding-bottom: 10px;
            margin-top: 40px;
        }
        
        .code-block {
            background: #2d3748;
            color: #e2e8f0;
            padding: 20px;
            border-radius: 10px;
            margin: 15px 0;
            font-family: 'Courier New', monospace;
            overflow-x: auto;
            font-size: 0.9rem;
        }
        
        .comment {
            color: #68d391;
            font-style: italic;
        }
        
        .output {
            background: #f7fafc;
            border: 2px solid #667eea;
            border-radius: 10px;
            padding: 15px;
            margin: 15px 0;
            font-family: 'Courier New', monospace;
        }
        
        .run-button {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 600;
            margin: 10px 5px;
            transition: all 0.3s ease;
        }
        
        .run-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(102, 126, 234, 0.3);
        }
        
        .section {
            margin: 30px 0;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 10px;
            border-left: 4px solid #667eea;
        }
        
        .key-point {
            background: #edf2f7;
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
            border-left: 4px solid #48bb78;
        }
        
        .warning {
            background: #fed7d7;
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
            border-left: 4px solid #f56565;
        }
        
        #console-output {
            background: #1a202c;
            color: #68d391;
            padding: 20px;
            border-radius: 10px;
            font-family: 'Courier New', monospace;
            min-height: 200px;
            max-height: 400px;
            overflow-y: auto;
            white-space: pre-wrap;
            margin: 20px 0;
        }
        
        .demo-container {
            background: #f0f4f8;
            padding: 20px;
            border-radius: 10px;
            margin: 15px 0;
        }
        
        .result-display {
            background: #e6fffa;
            border: 1px solid #38b2ac;
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
            font-family: monospace;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ðŸš€ DSA Set - Advanced Applications</h1>
        
        <div class="section">
            <h2>1. Set-Based Cache Implementation</h2>
            <div class="key-point">
                <strong>SET-BASED CACHE CONCEPT:</strong> Using Set to implement a simple cache that tracks recently accessed items.
                This is different from LRU cache - it just tracks uniqueness without ordering.
            </div>
            
            <div class="code-block">
class SimpleCache {
    constructor(maxSize = 100) {
        this.cache = new Set();
        this.maxSize = maxSize;
    }

    <span class="comment">// Add item to cache</span>
    add(item) {
        if (this.cache.size >= this.maxSize) {
            <span class="comment">// Remove the first item (FIFO - First In, First Out)</span>
            const firstItem = this.cache.values().next().value;
            this.cache.delete(firstItem);
        }
        this.cache.add(item);
    }

    <span class="comment">// Check if item exists in cache</span>
    has(item) {
        return this.cache.has(item);
    }

    <span class="comment">// Remove specific item</span>
    remove(item) {
        return this.cache.delete(item);
    }

    <span class="comment">// Clear cache</span>
    clear() {
        this.cache.clear();
    }

    <span class="comment">// Get cache size</span>
    size() {
        return this.cache.size;
    }

    <span class="comment">// Get all cached items</span>
    getAll() {
        return Array.from(this.cache);
    }
}
            </div>
            
            <button class="run-button" onclick="runCacheDemo()">Run Cache Demo</button>
            <div id="cache-result" class="result-display" style="display:none;"></div>
        </div>
        
        <div class="section">
            <h2>2. Set-Based Permission System</h2>
            <div class="key-point">
                <strong>PERMISSION SYSTEM CONCEPT:</strong> Using Set to manage user permissions for fast lookup and easy management.
                Sets are perfect for this because permissions are unique and need fast O(1) lookup.
            </div>
            
            <div class="code-block">
class PermissionSystem {
    constructor() {
        this.userPermissions = new Map(); <span class="comment">// userId -> Set of permissions</span>
        this.rolePermissions = new Map(); <span class="comment">// role -> Set of permissions</span>
    }

    <span class="comment">// Define role permissions</span>
    defineRole(role, permissions) {
        this.rolePermissions.set(role, new Set(permissions));
    }

    <span class="comment">// Assign role to user</span>
    assignRole(userId, role) {
        const rolePerms = this.rolePermissions.get(role);
        if (rolePerms) {
            if (!this.userPermissions.has(userId)) {
                this.userPermissions.set(userId, new Set());
            }
            <span class="comment">// Add all role permissions to user permissions</span>
            for (const perm of rolePerms) {
                this.userPermissions.get(userId).add(perm);
            }
        }
    }

    <span class="comment">// Grant specific permission to user</span>
    grantPermission(userId, permission) {
        if (!this.userPermissions.has(userId)) {
            this.userPermissions.set(userId, new Set());
        }
        this.userPermissions.get(userId).add(permission);
    }

    <span class="comment">// Check if user has permission</span>
    hasPermission(userId, permission) {
        return this.userPermissions.has(userId) && 
               this.userPermissions.get(userId).has(permission);
    }
}
            </div>
            
            <button class="run-button" onclick="runPermissionDemo()">Run Permission Demo</button>
            <div id="permission-result" class="result-display" style="display:none;"></div>
        </div>
        
        <div class="section">
            <h2>3. Set-Based Dependency Graph</h2>
            <div class="key-point">
                <strong>DEPENDENCY GRAPH CONCEPT:</strong> Using Set to manage dependencies between tasks/modules.
                Sets help track dependencies efficiently and detect circular dependencies.
            </div>
            
            <div class="code-block">
class DependencyGraph {
    constructor() {
        this.dependencies = new Map(); <span class="comment">// node -> Set of dependencies</span>
        this.dependents = new Map(); <span class="comment">// node -> Set of nodes that depend on this</span>
    }

    <span class="comment">// Add dependency (node depends on dependency)</span>
    addDependency(node, dependency) {
        <span class="comment">// Add to dependencies map</span>
        if (!this.dependencies.has(node)) {
            this.dependencies.set(node, new Set());
        }
        this.dependencies.get(node).add(dependency);

        <span class="comment">// Add to dependents map</span>
        if (!this.dependents.has(dependency)) {
            this.dependents.set(dependency, new Set());
        }
        this.dependents.get(dependency).add(node);
    }

    <span class="comment">// Check if there's a circular dependency</span>
    hasCircularDependency() {
        const visited = new Set();
        const recursionStack = new Set();

        const hasCycle = (node) => {
            if (recursionStack.has(node)) {
                return true; <span class="comment">// Found cycle</span>
            }
            if (visited.has(node)) {
                return false; <span class="comment">// Already processed</span>
            }

            visited.add(node);
            recursionStack.add(node);

            const deps = this.dependencies.get(node) || new Set();
            for (const dep of deps) {
                if (hasCycle(dep)) {
                    return true;
                }
            }

            recursionStack.delete(node);
            return false;
        };

        for (const node of this.dependencies.keys()) {
            if (!visited.has(node) && hasCycle(node)) {
                return true;
            }
        }
        return false;
    }
}
            </div>
            
            <button class="run-button" onclick="runDependencyDemo()">Run Dependency Demo</button>
            <div id="dependency-result" class="result-display" style="display:none;"></div>
        </div>
        
        <div class="section">
            <h2>4. Set-Based Tag System</h2>
            <div class="key-point">
                <strong>TAG SYSTEM CONCEPT:</strong> Using Set to implement a flexible tagging system for content categorization.
                Sets are perfect for tags because they should be unique per item and support efficient tag intersection operations.
            </div>
            
            <div class="code-block">
class TagSystem {
    constructor() {
        this.itemTags = new Map(); <span class="comment">// itemId -> Set of tags</span>
        this.tagItems = new Map(); <span class="comment">// tag -> Set of items with this tag</span>
    }

    <span class="comment">// Add tag to item</span>
    addTag(itemId, tag) {
        <span class="comment">// Add to item's tags</span>
        if (!this.itemTags.has(itemId)) {
            this.itemTags.set(itemId, new Set());
        }
        this.itemTags.get(itemId).add(tag);

        <span class="comment">// Add to tag's items</span>
        if (!this.tagItems.has(tag)) {
            this.tagItems.set(tag, new Set());
        }
        this.tagItems.get(tag).add(itemId);
    }

    <span class="comment">// Get items with multiple tags (AND operation)</span>
    getItemsWithAllTags(tags) {
        if (tags.length === 0) return [];

        <span class="comment">// Start with items that have the first tag</span>
        const result = new Set(this.tagItems.get(tags[0]) || new Set());

        <span class="comment">// Intersect with items that have other tags</span>
        for (let i = 1; i < tags.length; i++) {
            const itemsWithTag = this.tagItems.get(tags[i]) || new Set();
            for (const item of result) {
                if (!itemsWithTag.has(item)) {
                    result.delete(item);
                }
            }
        }

        return Array.from(result);
    }

    <span class="comment">// Get items with any of the tags (OR operation)</span>
    getItemsWithAnyTag(tags) {
        const result = new Set();
        for (const tag of tags) {
            const items = this.tagItems.get(tag) || new Set();
            for (const item of items) {
                result.add(item);
            }
        }
        return Array.from(result);
    }
}
            </div>
            
            <button class="run-button" onclick="runTagDemo()">Run Tag Demo</button>
            <div id="tag-result" class="result-display" style="display:none;"></div>
        </div>
        
        <div class="section">
            <h2>5. Set-Based Event System</h2>
            <div class="key-point">
                <strong>EVENT SYSTEM CONCEPT:</strong> Using Set to manage event listeners and prevent duplicate registrations.
                Sets ensure each listener is registered only once per event type.
            </div>
            
            <div class="code-block">
class EventSystem {
    constructor() {
        this.listeners = new Map(); <span class="comment">// event -> Set of listeners</span>
    }

    <span class="comment">// Add event listener</span>
    on(event, listener) {
        if (!this.listeners.has(event)) {
            this.listeners.set(event, new Set());
        }
        
        <span class="comment">// Check if listener already exists to prevent duplicates</span>
        if (this.listeners.get(event).has(listener)) {
            console.log(`Listener already registered for event: ${event}`);
            return false;
        }
        
        this.listeners.get(event).add(listener);
        console.log(`Listener added for event: ${event}`);
        return true;
    }

    <span class="comment">// Emit event to all listeners</span>
    emit(event, ...args) {
        if (!this.listeners.has(event)) {
            console.log(`No listeners for event: ${event}`);
            return;
        }

        console.log(`Emitting event: ${event} to ${this.listeners.get(event).size} listeners`);
        
        <span class="comment">// Create a copy of listeners to avoid issues if listeners are modified during iteration</span>
        const listeners = Array.from(this.listeners.get(event));
        
        for (const listener of listeners) {
            try {
                listener(...args);
            } catch (error) {
                console.error(`Error in listener for event ${event}:`, error);
            }
        }
    }

    <span class="comment">// Get number of listeners for an event</span>
    listenerCount(event) {
        return this.listeners.has(event) ? this.listeners.get(event).size : 0;
    }
}
            </div>
            
            <button class="run-button" onclick="runEventDemo()">Run Event Demo</button>
            <div id="event-result" class="result-display" style="display:none;"></div>
        </div>
        
        <div class="section">
            <h2>6. Set-Based State Management</h2>
            <div class="key-point">
                <strong>STATE MANAGEMENT CONCEPT:</strong> Using Set to manage application state, particularly for tracking active items,
                selected items, or loading states efficiently.
            </div>
            
            <div class="code-block">
class StateManager {
    constructor() {
        this.state = {
            selectedItems: new Set(),
            activeUsers: new Set(),
            loadingOperations: new Set(),
            completedTasks: new Set()
        };
    }

    <span class="comment">// Selected items management</span>
    selectItem(itemId) {
        this.state.selectedItems.add(itemId);
    }

    deselectItem(itemId) {
        this.state.selectedItems.delete(itemId);
    }

    toggleItemSelection(itemId) {
        if (this.state.selectedItems.has(itemId)) {
            this.state.selectedItems.delete(itemId);
        } else {
            this.state.selectedItems.add(itemId);
        }
    }

    isItemSelected(itemId) {
        return this.state.selectedItems.has(itemId);
    }

    getSelectedItems() {
        return Array.from(this.state.selectedItems);
    }

    <span class="comment">// Active users management</span>
    addUser(userId) {
        this.state.activeUsers.add(userId);
    }

    removeUser(userId) {
        this.state.activeUsers.delete(userId);
    }

    isUserActive(userId) {
        return this.state.activeUsers.has(userId);
    }

    getActiveUserCount() {
        return this.state.activeUsers.size;
    }

    <span class="comment">// Loading operations management</span>
    startLoading(operation) {
        this.state.loadingOperations.add(operation);
    }

    stopLoading(operation) {
        this.state.loadingOperations.delete(operation);
    }

    isLoading(operation) {
        return this.state.loadingOperations.has(operation);
    }

    isAnyLoading() {
        return this.state.loadingOperations.size > 0;
    }
}
            </div>
            
            <button class="run-button" onclick="runStateDemo()">Run State Demo</button>
            <div id="state-result" class="result-display" style="display:none;"></div>
        </div>
        
        <div id="console-output"></div>
        
        <div class="section">
            <h2>ðŸŽ¯ Key Takeaways</h2>
            <div class="key-point">
                <ul>
                    <li><strong>Sets are perfect for managing unique collections</strong></li>
                    <li><strong>Excellent for permission systems and dependency tracking</strong></li>
                    <li><strong>Ideal for tag systems and event listener management</strong></li>
                    <li><strong>Great for state management with boolean conditions</strong></li>
                    <li><strong>Provide O(1) operations for most use cases</strong></li>
                </ul>
            </div>
        </div>
    </div>

    <script>
        function clearConsole() {
            document.getElementById('console-output').textContent = '';
        }

        function log(message) {
            const output = document.getElementById('console-output');
            output.textContent += message + '\n';
            output.scrollTop = output.scrollHeight;
        }

        function showResult(elementId, content) {
            const element = document.getElementById(elementId);
            element.textContent = content;
            element.style.display = 'block';
        }

        // Simple Cache Demo
        class SimpleCache {
            constructor(maxSize = 100) {
                this.cache = new Set();
                this.maxSize = maxSize;
            }

            add(item) {
                if (this.cache.size >= this.maxSize) {
                    const firstItem = this.cache.values().next().value;
                    this.cache.delete(firstItem);
                }
                this.cache.add(item);
            }

            has(item) {
                return this.cache.has(item);
            }

            remove(item) {
                return this.cache.delete(item);
            }

            clear() {
                this.cache.clear();
            }

            size() {
                return this.cache.size;
            }

            getAll() {
                return Array.from(this.cache);
            }
        }

        function runCacheDemo() {
            clearConsole();
            log('=== CACHE DEMO ===');
            
            const cache = new SimpleCache(3);
            
            cache.add("item1");
            cache.add("item2");
            cache.add("item3");
            log(`Cache after adding 3 items: [${cache.getAll().join(', ')}]`);

            cache.add("item4"); // Should remove item1 (FIFO)
            log(`Cache after adding item4: [${cache.getAll().join(', ')}]`);
            log(`Has item2: ${cache.has("item2")}`);
            log(`Has item1: ${cache.has("item1")}`);

            showResult('cache-result', `Cache size: ${cache.size()}, Items: [${cache.getAll().join(', ')}]`);
        }

        // Permission System Demo
        class PermissionSystem {
            constructor() {
                this.userPermissions = new Map();
                this.rolePermissions = new Map();
            }

            defineRole(role, permissions) {
                this.rolePermissions.set(role, new Set(permissions));
            }

            assignRole(userId, role) {
                const rolePerms = this.rolePermissions.get(role);
                if (rolePerms) {
                    if (!this.userPermissions.has(userId)) {
                        this.userPermissions.set(userId, new Set());
                    }
                    for (const perm of rolePerms) {
                        this.userPermissions.get(userId).add(perm);
                    }
                }
            }

            grantPermission(userId, permission) {
                if (!this.userPermissions.has(userId)) {
                    this.userPermissions.set(userId, new Set());
                }
                this.userPermissions.get(userId).add(permission);
            }

            hasPermission(userId, permission) {
                return this.userPermissions.has(userId) && 
                       this.userPermissions.get(userId).has(permission);
            }

            getUserPermissions(userId) {
                return this.userPermissions.has(userId) ? 
                       Array.from(this.userPermissions.get(userId)) : [];
            }
        }

        function runPermissionDemo() {
            clearConsole();
            log('=== PERMISSION SYSTEM DEMO ===');
            
            const permissionSystem = new PermissionSystem();

            // Define roles
            permissionSystem.defineRole("admin", ["read", "write", "delete", "manage_users"]);
            permissionSystem.defineRole("editor", ["read", "write"]);
            permissionSystem.defineRole("viewer", ["read"]);

            // Assign roles to users
            permissionSystem.assignRole("user1", "admin");
            permissionSystem.assignRole("user2", "editor");
            permissionSystem.assignRole("user3", "viewer");

            // Grant additional permission
            permissionSystem.grantPermission("user2", "publish");

            // Test permissions
            log(`User1 can delete: ${permissionSystem.hasPermission("user1", "delete")}`);
            log(`User2 can delete: ${permissionSystem.hasPermission("user2", "delete")}`);
            log(`User2 can publish: ${permissionSystem.hasPermission("user2", "publish")}`);
            log(`User3 can write: ${permissionSystem.hasPermission("user3", "write")}`);

            showResult('permission-result', 
                `User1 permissions: [${permissionSystem.getUserPermissions("user1").join(', ')}]\n` +
                `User2 permissions: [${permissionSystem.getUserPermissions("user2").join(', ')}]`
            );
        }

        // Dependency Graph Demo
        class DependencyGraph {
            constructor() {
                this.dependencies = new Map();
                this.dependents = new Map();
            }

            addDependency(node, dependency) {
                if (!this.dependencies.has(node)) {
                    this.dependencies.set(node, new Set());
                }
                this.dependencies.get(node).add(dependency);

                if (!this.dependents.has(dependency)) {
                    this.dependents.set(dependency, new Set());
                }
                this.dependents.get(dependency).add(node);
            }

            getDependencies(node) {
                return this.dependencies.has(node) ? 
                       Array.from(this.dependencies.get(node)) : [];
            }

            getDependents(node) {
                return this.dependents.has(node) ? 
                       Array.from(this.dependents.get(node)) : [];
            }

            hasCircularDependency() {
                const visited = new Set();
                const recursionStack = new Set();

                const hasCycle = (node) => {
                    if (recursionStack.has(node)) return true;
                    if (visited.has(node)) return false;

                    visited.add(node);
                    recursionStack.add(node);

                    const deps = this.dependencies.get(node) || new Set();
                    for (const dep of deps) {
                        if (hasCycle(dep)) return true;
                    }

                    recursionStack.delete(node);
                    return false;
                };

                for (const node of this.dependencies.keys()) {
                    if (!visited.has(node) && hasCycle(node)) return true;
                }
                return false;
            }
        }

        function runDependencyDemo() {
            clearConsole();
            log('=== DEPENDENCY GRAPH DEMO ===');
            
            const depGraph = new DependencyGraph();
            depGraph.addDependency("C", "A");
            depGraph.addDependency("C", "B");
            depGraph.addDependency("D", "C");
            depGraph.addDependency("E", "D");

            log(`Dependencies of C: [${depGraph.getDependencies("C").join(', ')}]`);
            log(`Dependents of C: [${depGraph.getDependents("C").join(', ')}]`);
            log(`Has circular dependency: ${depGraph.hasCircularDependency()}`);

            // Add circular dependency
            depGraph.addDependency("A", "E");
            log(`Has circular dependency after adding A->E: ${depGraph.hasCircularDependency()}`);

            showResult('dependency-result', 
                `Circular dependency detected: ${depGraph.hasCircularDependency()}\n` +
                `Total dependencies: ${depGraph.dependencies.size}`
            );
        }

        // Tag System Demo
        class TagSystem {
            constructor() {
                this.itemTags = new Map();
                this.tagItems = new Map();
            }

            addTag(itemId, tag) {
                if (!this.itemTags.has(itemId)) {
                    this.itemTags.set(itemId, new Set());
                }
                this.itemTags.get(itemId).add(tag);

                if (!this.tagItems.has(tag)) {
                    this.tagItems.set(tag, new Set());
                }
                this.tagItems.get(tag).add(itemId);
            }

            getItemTags(itemId) {
                return this.itemTags.has(itemId) ? 
                       Array.from(this.itemTags.get(itemId)) : [];
            }

            getItemsWithTag(tag) {
                return this.tagItems.has(tag) ? 
                       Array.from(this.tagItems.get(tag)) : [];
            }

            getItemsWithAllTags(tags) {
                if (tags.length === 0) return [];

                const result = new Set(this.tagItems.get(tags[0]) || new Set());

                for (let i = 1; i < tags.length; i++) {
                    const itemsWithTag = this.tagItems.get(tags[i]) || new Set();
                    for (const item of result) {
                        if (!itemsWithTag.has(item)) {
                            result.delete(item);
                        }
                    }
                }

                return Array.from(result);
            }

            getItemsWithAnyTag(tags) {
                const result = new Set();
                for (const tag of tags) {
                    const items = this.tagItems.get(tag) || new Set();
                    for (const item of items) {
                        result.add(item);
                    }
                }
                return Array.from(result);
            }
        }

        function runTagDemo() {
            clearConsole();
            log('=== TAG SYSTEM DEMO ===');
            
            const tagSystem = new TagSystem();

            // Add tags to items
            tagSystem.addTag("item1", "javascript");
            tagSystem.addTag("item1", "tutorial");
            tagSystem.addTag("item1", "beginner");

            tagSystem.addTag("item2", "javascript");
            tagSystem.addTag("item2", "advanced");
            tagSystem.addTag("item2", "performance");

            tagSystem.addTag("item3", "python");
            tagSystem.addTag("item3", "tutorial");
            tagSystem.addTag("item3", "data-science");

            tagSystem.addTag("item4", "javascript");
            tagSystem.addTag("item4", "tutorial");

            log(`Tags for item1: [${tagSystem.getItemTags("item1").join(', ')}]`);
            log(`Items with 'javascript' tag: [${tagSystem.getItemsWithTag("javascript").join(', ')}]`);
            log(`Items with all tags ['javascript', 'tutorial']: [${tagSystem.getItemsWithAllTags(["javascript", "tutorial"]).join(', ')}]`);
            log(`Items with any tags ['python', 'javascript']: [${tagSystem.getItemsWithAnyTag(["python", "javascript"]).join(', ')}]`);

            showResult('tag-result', 
                `Total items tagged: ${tagSystem.itemTags.size}\n` +
                `Total unique tags: ${tagSystem.tagItems.size}`
            );
        }

        // Event System Demo
        class EventSystem {
            constructor() {
                this.listeners = new Map();
            }

            on(event, listener) {
                if (!this.listeners.has(event)) {
                    this.listeners.set(event, new Set());
                }
                
                if (this.listeners.get(event).has(listener)) {
                    log(`Listener already registered for event: ${event}`);
                    return false;
                }
                
                this.listeners.get(event).add(listener);
                log(`Listener added for event: ${event}`);
                return true;
            }

            emit(event, ...args) {
                if (!this.listeners.has(event)) {
                    log(`No listeners for event: ${event}`);
                    return;
                }

                log(`Emitting event: ${event} to ${this.listeners.get(event).size} listeners`);
                
                const listeners = Array.from(this.listeners.get(event));
                
                for (const listener of listeners) {
                    try {
                        listener(...args);
                    } catch (error) {
                        log(`Error in listener for event ${event}: ${error.message}`);
                    }
                }
            }

            listenerCount(event) {
                return this.listeners.has(event) ? this.listeners.get(event).size : 0;
            }
        }

        function runEventDemo() {
            clearConsole();
            log('=== EVENT SYSTEM DEMO ===');
            
            const eventSystem = new EventSystem();

            // Define listeners
            const listener1 = (data) => log(`Listener 1 received: ${data}`);
            const listener2 = (data) => log(`Listener 2 received: ${data}`);
            const listener3 = (data) => log(`Listener 3 received: ${data}`);

            // Add listeners
            eventSystem.on("data", listener1);
            eventSystem.on("data", listener2);
            eventSystem.on("click", listener3);

            // Try to add duplicate listener
            eventSystem.on("data", listener1);

            // Emit events
            eventSystem.emit("data", "Hello World!");
            eventSystem.emit("click", "{ x: 100, y: 200 }");

            showResult('event-result', 
                `Data event listeners: ${eventSystem.listenerCount("data")}\n` +
                `Click event listeners: ${eventSystem.listenerCount("click")}`
            );
        }

        // State Manager Demo
        class StateManager {
            constructor() {
                this.state = {
                    selectedItems: new Set(),
                    activeUsers: new Set(),
                    loadingOperations: new Set(),
                    completedTasks: new Set()
                };
            }

            selectItem(itemId) {
                this.state.selectedItems.add(itemId);
            }

            deselectItem(itemId) {
                this.state.selectedItems.delete(itemId);
            }

            toggleItemSelection(itemId) {
                if (this.state.selectedItems.has(itemId)) {
                    this.state.selectedItems.delete(itemId);
                } else {
                    this.state.selectedItems.add(itemId);
                }
            }

            isItemSelected(itemId) {
                return this.state.selectedItems.has(itemId);
            }

            getSelectedItems() {
                return Array.from(this.state.selectedItems);
            }

            addUser(userId) {
                this.state.activeUsers.add(userId);
            }

            removeUser(userId) {
                this.state.activeUsers.delete(userId);
            }

            isUserActive(userId) {
                return this.state.activeUsers.has(userId);
            }

            getActiveUserCount() {
                return this.state.activeUsers.size;
            }

            startLoading(operation) {
                this.state.loadingOperations.add(operation);
            }

            stopLoading(operation) {
                this.state.loadingOperations.delete(operation);
            }

            isLoading(operation) {
                return this.state.loadingOperations.has(operation);
            }

            isAnyLoading() {
                return this.state.loadingOperations.size > 0;
            }

            getStateSummary() {
                return {
                    selectedCount: this.state.selectedItems.size,
                    activeUserCount: this.state.activeUsers.size,
                    loadingOperations: this.state.loadingOperations.size,
                    completedTaskCount: this.state.completedTasks.size
                };
            }
        }

        function runStateDemo() {
            clearConsole();
            log('=== STATE MANAGEMENT DEMO ===');
            
            const stateManager = new StateManager();

            // Test item selection
            stateManager.selectItem("item1");
            stateManager.selectItem("item2");
            stateManager.selectItem("item3");
            log(`Selected items: [${stateManager.getSelectedItems().join(', ')}]`);
            log(`Is item2 selected: ${stateManager.isItemSelected("item2")}`);

            stateManager.toggleItemSelection("item2");
            log(`Selected items after toggle item2: [${stateManager.getSelectedItems().join(', ')}]`);

            // Test active users
            stateManager.addUser("user1");
            stateManager.addUser("user2");
            log(`Active user count: ${stateManager.getActiveUserCount()}`);
            log(`Is user1 active: ${stateManager.isUserActive("user1")}`);

            // Test loading operations
            stateManager.startLoading("fetchData");
            stateManager.startLoading("uploadFile");
            log(`Is fetchData loading: ${stateManager.isLoading("fetchData")}`);
            log(`Is any loading: ${stateManager.isAnyLoading()}`);

            stateManager.stopLoading("fetchData");
            log(`Loading operations after stopping fetchData: [${stateManager.state.loadingOperations.size ? 'uploadFile' : 'none'}]`);

            const summary = stateManager.getStateSummary();
            showResult('state-result', 
                `Selected: ${summary.selectedCount}, ` +
                `Active Users: ${summary.activeUserCount}, ` +
                `Loading: ${summary.loadingOperations}`
            );
        }

        // Run first demo on page load
        window.onload = function() {
            runCacheDemo();
        };
    </script>
</body>
</html>
